{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>The MAX78000 is a new breed of low-power microcontrollers built to thrive in the rapidly evolving AI at the edge market. These products include Maxim's proven ultra-low-power MCU IP along with deep neural network AI acceleration.</p> <p>The MAX78000 is an advanced system-on-chip featuring an Arm\u00ae Cortex\u00ae-M4 with FPU CPU to efficiently compute complex functions and algorithms with integrated power management. It also includes a 442KB weight CNN accelerator. The devices offer large on-chip memory with 512KB flash and up to 128KB SRAM. Multiple high-speed and low-power communications interfaces are supported, including high-speed SPI, I2C serial interface, and LPUART. Additional low-power peripherals include flexible low-power timers (LPTMR) and analog comparators.</p> <p>The high-level block diagram for the MAX78000 is shown in Figure 2-1.</p>"},{"location":"flash-controller/","title":"Flash Controller (FLC)","text":"<p>The MAX78000 flash controller manages read, write, and erase accesses to the internal flash and provides the following features:</p> <ul> <li>Up to 512KB total internal flash memory</li> <li>64 pages</li> <li>8,192 bytes per page</li> <li>2,048 words by 128 bits per page</li> <li>128-bit data reads and writes</li> <li>Page erase and mass erase support</li> <li>Write protection</li> </ul>"},{"location":"flash-controller/#instances","title":"Instances","text":"<p>The device includes one instance of the FLC. The 512KB of internal flash memory is programmable through the serial wire debug interface (in-system) or directly with software (in-application).</p> <p>The flash is organized as an array of 2,048 words by 128 bits, or 8,192 bytes per page. Table 7-1 shows the page start address and page end address of the internal flash memory.</p> <p>Table 7-1: MAX78000 Internal Flash Memory Organization </p> Instance Page Number Size (per page) Start Address End Address FLC0 1 8,192 Bytes 0x1000 0000 0x1000 1FFF 2 8,192 Bytes 0x1000 2000 0x1000 3FFF 3 8,192 Bytes 0x1000 4000 0x1000 5FFF 4 8,192 Bytes 0x1000 6000 0x1000 7FFF ... ... ... ... 63 8,192 Bytes 0x1007 C000 0x1007 DFFF 64 8,192 Bytes 0x1007 E000 0x1007 FFFF"},{"location":"flash-controller/#usage","title":"Usage","text":"<p>The flash controller manages write and erase operations for internal flash memory and provides a lock mechanism to prevent unintentional writes to the internal flash. In-application and in-system programming, page erase, and mass erase operations are supported.</p>"},{"location":"flash-controller/#clock-configuration","title":"Clock Configuration","text":"<p>The FLC requires a 1MHz internal clock. See Oscillator Sources for details. Use the FLC clock divisor to generate f<sub>FLCn_CLK</sub> = 1MHz, as shown in Equation 7-1. If using the IPO as the system clock, the FLC_CLKDIV.clkdiv should be set to 100 (0x64).</p> <p>Equation 7-1: FLC Clock Frequency </p> <p>f<sub>FLCn_CLK</sub> = f<sub>SYS_CLK</sub> / FLCn_CLKDIV.clkdiv = 1MHz</p> <p>$$ f_{\\text{FLCn_CLK}} = \\frac{f_{\\text{SYS_CLK}}}{\\text{FLCn_CLKDIV} \\cdot \\text{clkdiv}} = 1 \\, \\text{MHz} $$</p>"},{"location":"flash-controller/#lock-protection","title":"Lock Protection","text":"<p>A locking mechanism prevents accidental memory writes and erases. All write and erase operations require the FLC_CTRL.unlock field to be set to 2 before starting the operation. Writing any other value to the FLC_CTRL.unlock field results in:</p> <ol> <li>The flash instance remaining locked, or</li> <li>The flash instance is locked from the unlocked state.</li> </ol> <p>Note: If a write, page erase, or mass erase operation is started, and the unlock code was not set to 2, the flash controller hardware sets the access fail flag, FLC_INTR.af, to indicate an access violation occurred.</p>"},{"location":"flash-controller/#flash-write-width","title":"Flash Write Width","text":"<p>The FLC supports write widths of 128-bits only. The target address bits FLC_ADDR[3:0] are ignored, resulting in 128-bit address alignment.</p> <p>Table 7-2: Valid Addresses Flash Writes </p> FLC_ADDR[31:0] Bit Number 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 128-bit Write 1 0 0 0 0 0 0 0 0 0 0 0 x x x x x x x x x x x x x x x x 0 0 0 0"},{"location":"flash-controller/#flash-write","title":"Flash Write","text":"<p>Writes to a flash address are only successful if the target address is already in its erased state. Perform the following steps to write to a flash memory address:</p> <ol> <li>If desired, enable the flash controller interrupts by setting the FLC_INTR.afie and FLC_INTR.doneie bits.</li> <li>Read the FLC_CTRL.pend bit until it returns 0.</li> <li>Configure the FLC_CLKDIV.clkdiv field to achieve a 1MHz frequency based on the selected SYS_CLK frequency.</li> <li>Set the FLC_ADDR register to a valid target address. See Table 7-2 for details.</li> <li> <p>Set FLC_DATA3, FLC_DATA2, FLC_DATA1, and FLC_DATA0 to the data to write.</p> <p>a. FLC_DATA3 is the most significant word, and FLC_DATA0 is the least significant word.</p> <p>i. Each word of the data to write follows the little-endian format where the least significant byte of the word is stored at the lowest-numbered byte, and the most significant byte is stored at the highest-numbered byte.</p> </li> <li> <p>Set the FLC_CTRL.unlock field to 2 to unlock the flash.</p> </li> <li>Set the FLC_CTRL.wr field to 1.     a. The hardware automatically clears this field when the write operation is complete.</li> <li>The FLC_INTR.done field is set to 1 by hardware when the write completes.     a. An interrupt is generated if the FLC_INTR.doneie field is set to 1.</li> <li>If an error occurred, the FLC_INTR.af field is set to 1 by hardware. An interrupt is generated if the FLC_INTR.afie field is set to 1.</li> <li>Set the FLC_CTRL.unlock field to any value other than 2 to re-lock the flash.</li> </ol> <p>Note: Code execution can occur within the same flash instance as targeted programming.</p>"},{"location":"flash-controller/#page-erase","title":"Page Erase","text":"<p>CAUTION: Care must be taken not to erase the page from which the application software is currently executing.</p> <p>Perform the following to erase a page of a flash memory instance:</p> <ol> <li>If desired, enable flash controller interrupts by setting the FLC_INTR.afie and FLC_INTR.doneie bits.</li> <li>Read the FLC_CTRL.pend bit until it returns 0.</li> <li>Configure FLC_CLKDIV.clkdiv to match the SYS_CLK frequency.</li> <li>Set the FLC_ADDR register to an address within the target page to be erased. FLC_ADDR[12:0] is ignored by the FLC to ensure the address is page-aligned.</li> <li>Set FLC_CTRL.unlock to 2 to unlock the flash instance.</li> <li>Set FLC_CTRL.erase_code to 0x55 for page erase.</li> <li>Set FLC_CTRL.pge to 1 to start the page erase operation.</li> <li>The FLC_CTRL.pend bit is set by the flash controller while the page erase is in progress, and the FLC_CTRL.pge and FLC_CTRL.pend are cleared by the flash controller when the page erase is complete.</li> <li>FLC_INTR.done is set by hardware when the page erase completes, and if an error occurred, the FLC_INTR.af flag is set. These bits generate a flash interrupt if the interrupt enable bits are set.</li> <li>Set FLC_CTRL.unlock to any value other than 2 to re-lock the flash instance.</li> </ol>"},{"location":"flash-controller/#mass-erase","title":"Mass Erase","text":"<p>CAUTION: Care must be taken not to erase the flash from which application software is currently executing.</p> <p>Mass erase clears the internal flash memory on an instance basis. Perform the following steps to mass erase a single flash memory instance:</p> <ol> <li>Read the FLC_CTRL.pend bit until it returns 0.</li> <li>Configure FLC_CLKDIV.clkdiv to match the SYS_CLK frequency.</li> <li>Set FLC_CTRL.unlock to 2 to unlock the internal flash.</li> <li>Set FLC_CTRL.erase_code to 0xAA for mass erase.</li> <li>Set FLC_CTRL.me to 1 to start the mass erase operation.</li> <li>The FLC_CTRL.pend bit is set by the flash controller while the mass erase is in progress, and the FLC_CTRL.me and FLC_CTRL.pend are cleared by the flash controller when the mass erase is complete.</li> <li>FLC_INTR.done is set by the flash controller when the mass erase completes, and if an error occurred, the FLC_INTR.af flag is set. These bits generate a flash interrupt if the interrupt enable bits are set.</li> <li>Set FLC_CTRL.unlock to any value other than 2 to re-lock the flash instance.</li> </ol>"},{"location":"flash-controller/#registers","title":"Registers","text":"<p>See Table 3-3 for the base address of this peripheral/module. See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and peripheral-specific resets.</p> <p>Note: The FLC registers are reset only on a POR. System reset, soft reset, and peripheral reset do not affect the FLC register values.</p> <p>Table 7-3: Flash Controller Register Summary </p> Offset Register Name Access Description [0x0000] FLC_ADDR R/W Flash Controller Address Pointer Register [0x0004] FLC_CLKDIV R/W Flash Controller Clock Divisor Register [0x0008] FLC_CTRL R/W Flash Controller Control Register [0x0024] FLC_INTR R/W Flash Controller Interrupt Register [0x0030] FLC_DATA0 R/W Flash Controller Data Register 0 [0x0034] FLC_DATA1 R/W Flash Controller Data Register 1 [0x0038] FLC_DATA2 R/W Flash Controller Data Register 2 [0x003C] FLC_DATA3 R/W Flash Controller Data Register 3 [0x0040] FLC_ACTRL R/W Flash Controller Access Control Register [0x0080] FLC_WELR0 R/W Flash Write/Erase Lock 0 Register [0x0088] FLC_WELR1 R/W Flash Write/Erase Lock 1 Register [0x0090] FLC_RLR0 R/W Flash Read Lock 0 Register [0x0098] FLC_RLR1 R/W Flash Read Lock 1 Register"},{"location":"flash-controller/#register-details","title":"Register Details","text":"<p>Table 7-4: Flash Controller Address Pointer Register </p> Flash Controller Address Pointer FLC_ADDR [0x0000] Bits Name Access Reset Description 31:0 addr R/W 0x1000 0000 Flash AddressThis field contains the target address for a write operation. A valid internal flash memory address is required for all write operations. <p>Table 7-5: Flash Controller Clock Divisor Register </p> Flash Controller Clock Divisor FLC_CLKDIV [0x0004] Bits Name Access Reset Description 31:8 - RO - Reserved 7:0 clkdiv R/W 0x64 Flash Controller Clock DivisorThe APB clock is divided by the value in this field to generate the FLCn peripheral clock, f<sub>FLC_CLK</sub>. The FLC peripheral clock must equal 1MHz. The default on POR, system reset, and watchdog reset is 100, resulting in f<sub>FLC_CLK</sub> = 1MHz when IPO is the system oscillator. The FLC peripheral clock is only used during erase and program functions and not during read functions. See Clock Configuration for additional details. <p>Table 7-6: Flash Controller Control Register </p> Flash Controller Control FLC_CTRL [0x0008] Bits Name Access Reset Description 31:28 unlock R/W 0 Flash UnlockWrite the unlock code, 2, before any flash write or erase operation to unlock the flash. Writing any other value to this field locks the internal flash. <p>2: Flash unlock code</p> 27:26 - RO - Reserved 25 lve R/W 0 Low Voltage EnableSet this field to 1 to enable low voltage operation for the flash memory.          <p>0: Low voltage operation disabled (Default).</p> <p>1: Low voltage operation enabled.</p> 24 pend RO 0 Flash Busy FlagWhen this field is set, writes to all flash registers, except the FLC_INTR register, are ignored by the flash controller. This bit is cleared by hardware once the flash becomes accessible.         <p>Note:If the flash controller is busy (FLC_CTRL.pend = 1), reads, writes, and erase operations are not allowed and result in an access failure (FLC_INTR.af = 1).</p> <p>0: Low voltage operation disabled (Default).</p> <p>1: Low voltage operation enabled.</p> 23:16 - RO 0 Reserved 15:8 erase_code R/W 0 Erase CodeBefore an erase operation, this field must be set to 0x55 for a page erase or 0xAA for a mass erase. The flash must be unlocked before setting the erase code. This field is automatically cleared after the erase operation is complete.          <p>0x00: Erase disabled.</p> <p>0x55: Page erase code.</p> <p>0xAA: Mass erase code.</p> 7:3 - RO 0 Reserved 2 pge R/W1 0 Page EraseWrite a 1 to this field to initiate a page erase at the address in FLC_ADDR.addr. The flash must be unlocked before attempting a page erase. See FLC_CTRL.unlock for details.         <p>The flash controller hardware clears this bit when a page erase operation is complete.</p> <p>0: Normal operation.</p> <p>1: Write a 1 to initiate a page erase. If this field reads 1, a page erase operation is in progress.</p> 1 me R/W1 0 Mass EraseWrite a 1 to this field to initiate a mass erase of the internal flash memory. The flash must be unlocked before attempting a mass erase. See FLC_CTRL.unlock for details. The flash controller hardware clears this bit when the mass erase operation completes.          <p>0: Normal operation.</p> <p>1: Initiate mass erase.</p> 0 wr R/W1O 0 WriteIf this field reads 0, no write operation is pending for the flash. To initiate a write operation, set this bit to 1, and the flash controller writes to the address set in the FLC_ADDR register.          <p>0: Normal operation.</p> <p>1: Write 1 to initiate a write operation. If this field reads 1, a write operation is in progress.</p> Note: This field is protected and cannot be set to 0 by application software. <p>Table 7-7: Flash Controller Interrupt Register </p> Flash Controller Interrupt FLC_INTR [0x0024] Bits Name Access Reset Description 31:10 - RO 0 Reserved 9 afie R/W 0 Flash Access Fail Interrupt EnableSet this bit to 1 to enable interrupts on flash access failures.        <p>0: Disabled</p> <p>1: Enabled</p> 8 doneie R/W 0 Flash Operation Complete Interrupt EnableSet this bit to 1 to enable interrupts on flash operations complete.        <p>0: Disabled</p> <p>1: Enabled</p> 7:2 - RO 0 Reserved 1 af R/W0C 0 Flash Access Fail Interrupt FlagThis bit is set when an attempt is made to write or erase the flash while the flash is busy or locked. Only hardware can set this bit to 1. Writing a 1 to this bit has no effect. This bit is cleared by writing a 0.        <p>0: No access failure has occurred.</p> <p>1: Access failure occurred.</p> 0 done R/W0C 0 Flash Operation Complete Interrupt FlagThis flag is automatically set by hardware after a flash write or erase operation completes.        <p>0: Operation not complete or not in process.</p> <p>1: Flash operation complete.</p> <p>Table7-8: Flash Controller Data 0 Register </p> Flash Controller Data 0 FLC_DATA0 [0x0030] Bits Name Access Reset Description 31:0 data R/W 0 Flash Data 0Flash data for bits 31:0. <p>Table 7-9: Flash Controller Data Register 1 </p> Flash Controller Data 1 FLC_DATA1 [0x0030] Bits Name Access Reset Description 31:0 data R/W 0 Flash Data 1Flash data for bits 63:32. <p>Table 7-10: Flash Controller Data Register 2 </p> Flash Controller Data 2 FLC_DATA2 [0x0030] Bits Name Access Reset Description 31:0 data R/W 0 Flash Data 2Flash data for bits 95:64. <p>Table 7-11: Flash Controller Data Register 3 </p> Flash Controller Data 3 FLC_DATA3 [0x0030] Bits Name Access Reset Description 31:0 data R/W 0 Flash Data 3Flash data for bits 127:96. <p>Table 7-12: Flash Controller Access Control Register </p> Flash Controller Access Control FLC_ACTRL [0x0040] Bits Name Access Reset Description 31:0 actrl R/W 0 Access ControlWhen this register is written with the access control sequence, the information block can be accessed. See Information Block Flash Memory for details. <p>Table 7-13: Flash Write/Lock 0 Register </p> Flash Write/Lock 0 FLC_WELR0 [0x0080] Bits Name Access Reset Description 31:0 welr0 R/W1C 0xFFFF FFFF Flash Write/Lock BitEach bit in this register maps to a page of the internal flash. FLC_WELR0[0] maps to page 0 of the flash, and FLC_WELR0[31] maps to page 31. Each flash page is 8,192 bytes. Write a 1 to a bit position in this register, and the corresponding page of flash is immediately locked. The page protection can only be unlocked by an external reset or a POR.        <p>0: The corresponding page of flash is write protected.</p> <p>1: The corresponding page of flash is not write protected.</p> <p>Table 7-14: Flash Write/Lock 1 Register </p> Flash Write/Lock 1 FLC_WELR1 [0x0088] Bits Name Access Reset Description 31:0 welr1 R/W1C 0xFFFF FFFF Flash Write/Lock BitEach bit in this register maps to a page of the internal flash. FLC_WELR1[0] maps to page 32 of the flash, and FLC_WELR1[31] maps to page 63 of flash. Each flash page is 8,192 bytes. Write a 1 to a bit position in this register, and the corresponding page of flash is immediately locked. The page protection can only be unlocked by an external reset or a POR.        <p>0: The corresponding flash page is write protected.</p> <p>1: The corresponding flash page is not write protected.</p> <p>Table 7-15: Flash Read Lock 0 Register </p> Flash Read Lock 0 FLC_RLR0 [0x0090] Bits Name Access Reset Description 31:0 rlr0 R/W1C 0xFFFF FFFF Read Lock BitEach bit in this register maps to a page of the internal flash. FLC_RLR0[0] maps to page 0 of the flash, and FLC_RLR0[31] maps to page 31 of flash. Each flash page is 8,192 bytes. Write a 1 to a bit position in this register, and the corresponding page of flash is immediately read protected. The page\u2019s read protection can only be unlocked by an external reset or a POR.        <p>0: The corresponding flash page is read protected.</p> <p>1: The corresponding flash page is not read protected.</p> <p>Table 7-16: Flash Read Lock 1 Register </p> Flash Read Lock 1 FLC_RLR1 [0x0098] Bits Name Access Reset Description 31:0 rlr1 R/W1C 0xFFFF FFFF Read Lock BitEach bit in this register maps to a page of the internal flash. FLC_RLR1[0] maps to page 32 of the flash, and FLC_RLR1[31] maps to page 63 of flash. Each flash page is 8,192 bytes. Write a 1 to a bit position in this register, and the corresponding page of flash is immediately read protected. The page\u2019s read protection can only be unlocked by an external reset or a POR.        <p>0: The corresponding flash page is read protected.</p> <p>1: The corresponding flash page is not read protected.</p>"},{"location":"memory-register-mapping-access/","title":"Memory, Register, Mapping, and Access","text":""},{"location":"memory-register-mapping-access/#overview","title":"Overview","text":"<p>The Arm Cortex-M4 architecture defines a standard memory space for unified code and data access. This memory space is addressed in units of single bytes but is most typically accessed in 32-bit (4 byte) units. It may also be accessed, depending on the implementation, in 8-bit (1 byte) or 16-bit (2 byte) widths. The total range of the memory space is 32 bits wide (4GB addressable total), from addresses 0x0000 0000 to 0xFFFF FFFF.</p> <p>However, it is important to note that the architectural definition does not require the entire 4GB memory range to be populated with addressable memory instances.</p>"},{"location":"memory-register-mapping-access/#standard-memory-regions","title":"Standard Memory Regions","text":"<p>Several standard memory regions are defined for the Arm Cortex-M4 (CPU0) and RISC-V (CPU1) architectures; many of these are optional for the system integrator. At a minimum, the MAX78000 must contain some code and data memory for application software, stack, and variable space for CPU0.</p>"},{"location":"memory-register-mapping-access/#code-space","title":"Code Space","text":"<p>The code space area of memory is designed to contain the primary memory used for code execution by the device. This memory area is defined from byte address range 0x0000 0000 to 0x1FFF FFFF (0.5GB maximum). The Cortex-M4 core and Arm debugger use two different standard core bus masters to access this memory area. The I-Code AHB bus master is used for instruction decode fetching from code memory, while the D-Code AHB bus master is used for data fetches from code memory. This is arranged so that data fetches avoid interfering with instruction execution. Additionally, the RV32 uses the D-BUS to access code memory in this area and the I-Bus to access data fetches from the code memory.</p> <p>The MAX78000 code memory mapping is illustrated in Figure 3-1 and Figure 3-2. The code space memory area contains the main internal flash memory, which holds most of the software executed on the device. The internal flash memory is mapped into both code and data space from 0x1000 0000 to 0x1007 FFFF. The main program flash memory is 512KB and consists of 64 logical pages of 8,192 Bytes per page.</p> <p>This program memory area must also contain the default system vector table and the initial settings for all system exception handlers and interrupt handlers for the CM4 core. The reset vector for the device is 0x0000 0000 and contains the device ROM code that transfers execution to user code at address 0x1000 0000.</p> <p>The code space memory on the MAX78000 also contains the mapping for the flash information block, from 0x1080 0000 to 0x1080 3FFF. However, this mapping is only present during production test; it is disabled once the information block has been loaded with valid data and the info block lockout option has been set. This memory is accessible for data reads only and cannot be used for code execution. See Information Block Flash Memory for additional details.</p>"},{"location":"memory-register-mapping-access/#internal-cache-memory","title":"Internal Cache Memory","text":"<p>The MAX78000 includes a dedicated unified internal cache controller with 16,384 bytes of internal cache memory (ICC0) for the CM4 core. Optionally, sysram3 can be used as a unified internal cache controller (ICC1) for the RV32.</p> <p>The unified internal cache memory is used to cache data and instructions fetched through the I-Code bus for the CM4 or the IBUS for the RV32 from the internal flash memory. See section Unified Internal Cache Controller for detailed instructions on enabling the unified internal cache controllers.</p>"},{"location":"memory-register-mapping-access/#information-block-flash-memory","title":"Information Block Flash Memory","text":"<p>The information block is a separate area of the internal flash memory and is 16,384 Bytes. The information block is used to store trim settings (option configuration and analog trim) and other nonvolatile device-specific information. The information block also contains the device's unique serial number (USN). The USN is a 104-bit field. USN bits 0 thru 7 contain the die revision.</p> <p>Figure 3-5: Unique Serial Number Format </p> Bit Position 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 0x10800000 USN bits 16-0 x x x x x x x x x x x x x x x 0x10800004 x USN bits 47-17 0x10800000 USN bits 64-48 x x x x x x x x x x x x x x x 0x1080000C x USN bits 95-65 0x10800010 x x x x x x x x x USN bits 103-96 x x x x x x x x x x x x x x x <p>Reading the USN requires unlocking the information block. Unlocking the information block does not enable write access to the block but allows the contents of the USN to be read from the block. Unlock the information block using the following steps:</p> <ol> <li>Write 0x3A7F 5CA3 to FLC_ACTRL.</li> <li>Write 0xA1E3 4F20 to FLC_ACTRL.</li> <li>Write 0x9608 B2C1 to FLC_ACTRL.</li> <li>The information block is now read-only accessible.</li> </ol> <p>To re-lock the information block to prevent access, write any 32-bit word to FLC_ACTRL.</p>"},{"location":"memory-register-mapping-access/#sram-space","title":"SRAM Space","text":"<p>The SRAM area of memory is intended to contain the primary SRAM data memory of the device and is defined from byte address range 0x2000 0000 to 0x3FFF FFFF (0.5GB maximum). This memory can be used for general-purpose variable and data storage, code execution, the CM4 stack, and the RV32 stack. The MAX78000 CM4's data memory mapping is illustrated in Figure 3-1. The MAX78000 RV32's data memory mapping is illustrated in Figure 3-4.</p> <p>The system SRAM configuration is defined in Table 3-1. Additionally, the CNN memory is covered in the CNN chapter in the section Memory Configuration.</p> <p>The SRAM area contains the main system RAM. The size of the internal general-purpose data SRAM is 128KB. The SRAM is divided into four blocks and consists of the contiguous address range from 0x2000 0000 to 0x2001 FFFF. The SRAM area on the MAX78000 can be used for data storage and code execution by the CM4. The RV32 is limited to sysram2 and sysram3 for code and data storage.</p> <p>Note: After a POR, the CM4 has access to all four SRAM regions. sysram2 and sysram3 can be configured to restrict access from the CM4 to prevent unintended modifications of these SRAM instances by the CM4. Set the FCR_URVCTRL.memsel field to 1 to set the RV32 core as the exclusive master for sysram2 and sysram3.</p> <p>Code stored in the SRAM is accessed directly for execution (using the system bus) and is not cached. The SRAM is also where the CM4 and RV32 stack must be located, as it is the only general-purpose SRAM on the device capable of this function.</p> <p>Table 3-1: System SRAM Configuration </p> System RAM Block # Size Start Address End Address CM4 Accessible RV32 Accessible sysram0 32KB 0x2000 0000 0x2000 7FFF \u2713 No sysram1 32KB 0x2000 8000 0x2000 FFFF \u2713 No sysram2 48KB 0x2001 0000 0x2001 BFFF Configurable \u2713 sysram3 16KB 0x2001 C000 0x2001 FFFF Configurable \u2713 (Optional ICC1) <p>The MAX78000 specific AHB Bus Masters can access the SRAM to use as general storage or working space.</p> <p>The entirety of the SRAM space on the MAX78000 is contained within the dedicated Arm Cortex-M4 SRAM bit-banding region from 0x2000 0000 to 0x200F FFFF (1MB maximum for bit-banding). This means that the CPU can access the entire SRAM either using standard byte/word/doubleword access or using bit-banding operations. The bit-banding mechanism allows any single bit of any given SRAM byte address location to be set, cleared, or read individually by reading from or writing to a corresponding doubleword (32-bit wide) location in the bit-banding alias area.</p> <p>The alias area for the SRAM bit-banding is located beginning at 0x2200 0000 and is a total of 32MB maximum, which allows the entire 128KB bit banding area to be accessed. Each 32-bit (4 byte aligned) address location in the bit-banding alias area translates into a single bit access (read or write) in the bit-banding primary area. Reading from the location performs a single bit read while writing either a 1 or 0 to the location performs a single bit set or clear.</p> <p>Note: The Arm Cortex-M4 core translates the access in the bit-banding alias area into the appropriate read cycle (for a single bit read) or a read-modify-write cycle (for a single bit set or clear) of the bit-banding primary area. Bit-banding is a core function (i.e., not a function of the SRAM interface layer or the AHB bus layer) and thus is only applicable to accesses generated by the core. Reads and writes to the bit-banding alias area by other (non-Arm-core) bus masters does not trigger a bit-banding operation and instead results in an AHB bus error.</p>"},{"location":"memory-register-mapping-access/#peripheral-space","title":"Peripheral Space","text":"<p>The peripheral space area of memory is intended to map control registers, internal buffers, and other features needed for the software control of non-core peripherals. It is defined from byte address range 0x4000 0000 to 0x5FFF FFFF (0.5GB maximum). On the MAX78000, all device-specific module registers are mapped to this memory area and any local memory buffers or FIFOs that are required by modules.</p> <p>As with the SRAM region, there is a dedicated 1MB area at the bottom of this memory region (from 0x4000 0000 to 0x400F FFFF) used for bit-banding operations by the Arm core. Four-byte-aligned read/write operations in the peripheral bit-banding alias area (32MB in length, from 0x4200 0000 to 0x43FF FFFF) are translated by the core into read/mask/shift or read/modify/write operation sequences to the appropriate byte location in the bit-banding area.</p> <p>Note: The bit-banding operation within peripheral memory space is, like bit-banding function in SRAM space, a core remapping function. As such, it is only applicable to operations performed directly by the Arm core. If another memory bus master accesses the peripheral bit-banding alias region, the bit-banding remapping operation does not occur. In this case, the bit-banding alias region appears to be a non-implemented memory area (causing an AHB bus error).</p> <p>On the MAX78000, access to the region containing most peripheral registers (0x4000 0000 to 0x400F FFFF) goes from the AHB bus through an AHB-to-APB bridge enabling the peripheral modules to operate on the lower power APB bus matrix. This also ensures that peripherals with slower response times do not tie up bandwidth on the AHB bus, which must necessarily have a faster response time since it handles main application instruction and data fetching.</p>"},{"location":"memory-register-mapping-access/#aes-key-and-working-space-memory","title":"AES Key and Working Space Memory","text":"<p>The AES key memory and working space for AES operations (including input and output parameters) are in a dedicated register file memory tied to the AES engine block. This AES memory is mapped into AHB space for rapid software access.</p>"},{"location":"memory-register-mapping-access/#system-area-private-peripheral-bus","title":"System Area (Private Peripheral Bus)","text":"<p>The system area (private peripheral bus) memory space contains register areas for functions that are only accessible by the Arm core itself (and the Arm debugger, in certain instances). It is defined from byte address range 0xE000 0000 to 0xE00F FFFF. This APB bus is restricted and can only be accessed by the Arm core and core-internal functions. It cannot be accessed by other modules which implement AHB memory masters, such as the DMA interface.</p> <p>In addition to being restricted to the core, application software can only access this area when running in privileged execution mode (instead of the standard user thread execution mode). This helps ensure that critical system settings controlled in this area are not altered inadvertently or by errant code that should not access this area.</p> <p>Core functions controlled by registers mapped to this area include the SysTick timer, debug and tracing functions, the nested vector interrupt controller (NVIC), and the flash breakpoint controller.</p>"},{"location":"memory-register-mapping-access/#ahb-interfaces","title":"AHB Interfaces","text":"<p>The following sections detail memory accessibility on the AHB and the organization of AHB master and slave instances.</p>"},{"location":"memory-register-mapping-access/#arm-core-ahb-interfaces","title":"Arm Core AHB Interfaces","text":""},{"location":"memory-register-mapping-access/#i-code","title":"I-Code","text":"<p>The Arm core uses the I-Code AHB master for instruction fetching from memory instances located in code space from byte addresses 0x0000 0000 to 0x1FFF FFFF. This bus master is used to fetch instructions from the internal flash memory.</p> <p>Instructions fetched by this bus master are returned by the cache, which in turn triggers a cache line fill cycle to fetch instructions from the internal flash memory when a cache miss occurs.</p>"},{"location":"memory-register-mapping-access/#d-code","title":"D-Code","text":"<p>The Arm core uses the D-Code AHB master for data fetches from memory instances in code space from byte addresses 0x0000 0000 to 0x1FFF FFFF. This bus master has access to the internal flash memory and the information block.</p>"},{"location":"memory-register-mapping-access/#system","title":"System","text":"<p>The Arm core uses the system AHB master for all instruction fetches, and data read and write operations involving the SRAM data cache. The APB mapped peripherals (through the AHB-to-APB bridge) and AHB mapped peripheral and memory areas are also accessed using this bus master.</p>"},{"location":"memory-register-mapping-access/#ahb-slaves","title":"AHB Slaves","text":""},{"location":"memory-register-mapping-access/#standard-dma","title":"Standard DMA","text":"<p>The standard DMA AHB slave has access to all non-core memory areas accessible by the system bus. The standard DMA does not have access to the internal flash memory or Information blocks.</p>"},{"location":"memory-register-mapping-access/#cnn-and-cnn-tx-fifo","title":"CNN and CNN TX FIFO","text":"<p>The CNN and CNN TX FIFO AHB slaves have access to all non-core memory areas accessible by the system bus. They do not have access to the internal flash memory or information blocks.</p>"},{"location":"memory-register-mapping-access/#spio","title":"SPIO","text":"<p>The SPI0 AHB slave has access to all non-core memory areas accessible by the system bus. SPI0 does not have access to the internal flash memory or information blocks.</p>"},{"location":"memory-register-mapping-access/#ahb-slave-base-address-map","title":"AHB Slave Base Address Map","text":"<p>Table 3-2 contains the base address for each of the AHB slave peripherals. The base address for a given peripheral is the start of the register map for the peripheral. For a given peripheral, the address for a register within the peripheral is defined as the peripheral's AHB base address plus the register's offset.</p> <p>Table 3-2: AHB Slave Base Address Map </p> AHB Slave Register Name Register Prefix AHB Base Address AHB End Address SPI0 SPI0_ 0x400B E000 0x400B E3FF CNN TX FIFO CNN_FIFO_ 0x400C 0400 0x400C 0400"},{"location":"memory-register-mapping-access/#peripheral-register-map","title":"Peripheral Register Map","text":""},{"location":"memory-register-mapping-access/#apb-peripheral-base-address-map","title":"APB Peripheral Base Address Map","text":"<p>Table 3-3 contains the base address for each of the APB mapped peripherals. The base address for a given peripheral is the start of the register map for the peripheral. For a given peripheral, the address for a register within the peripheral is defined as the APB peripheral base address plus the registers offset.</p> <p>Table 3-3: APB Peripheral Base Address Map </p> Peripheral Register Name Register Prefix APB Base Address APB End Address Global ControlGCR_0x4000 00000x4000 03FF System InterfaceSIR_0x4000 0400 Watchdog Timer 0WDT0_0x4000 30000x4000 33FF Dynamic Voltage Scaling ControllerDVS_0x4000 3C000x4000 3C3F Single Input Multiple OutputSIMO_0x4000 44000x4000 47FF Trim System InitializationTRIMSIR_0x4000 54000x4000 57FF General Control FunctionGCFR_0x4000 58000x4000 5BFF Real time ClockRTC_0x4000 60000x4000 63FF Wakeup TimerWUT_0x4000 64000x4000 67FF Power SequencerPWRSEQ_0x4000 68000x4000 6BFF Miscellaneous ControlMCR_0x4000 6C000x4000 6FFF AESAES_0x4000 74000x4000 77FF AES KeyAESKEY_0x4000 78000x4000 7BFF GPIO Port 0GPIO0_0x4000 80000x4000 8FFF GPIO Port 1GPIO1_0x4000 90000x4000 9FFF Parallel Camera InterfacePCIF_0x4000 E0000x4000 EFFF CRCCRC_0x4000 F0000x4000 FFFF Timer 0TMR0_0x4001 00000x4001 0FFF Timer 1TMR1_0x4001 10000x4001 1FFF Timer 2TMR2_0x4001 20000x4001 2FFF Timer 3TMR3_0x4001 30000x4001 3FFF I2C 0I2C0_0x4001 D0000x4001 DFFF I2C 1I2C1_0x4001 E0000x4001 EFFF I2C 2I2C2_0x4001 F0000x4001 FFFF Standard DMADMA_0x4002 80000x4002 8FFF Flash Controller 0FLC0_0x4002 90000x4002 93FF Instruction-Cache Controller 0 (CM4)ICC0_0x4002 A0000x4002 A7FF Instruction Cache Controller 1 (RV32)ICC1_0x4002 A8000x4002 AFFF ADCADC_0x4003 40000x4003 4FFF Pulse Train EnginePT_0x4003 C0000x4003 C09F 1-Wire MasterOWM0_0x4003 D0000x4003 DFFF SemaphoreSEMA_0x4003 E0000x4003 EFFF UART 0UART0_0x4004 20000x4004 2FFF UART 1UART1_0x4004 30000x4004 3FFF UART 2UART2_0x4004 40000x4004 4FFF SPI1SPI1_0x4004 60000x4004 7FFF TRNGTRNG_0x4004 D0000x4004 DFFF I2SI2S_0x4006 00000x4006 0FFF Low Power General ControlLPGCR_0x4008 00000x4008 03FF GPIO Port 2GPIO2_0x4008 04000x4008 05FF Low Power Watchdog Timer 0 (WDT1)WDT1_0x4008 08000x4008 0BFF Low Power Timer 4TMR4_0x4008 0C000x4008 0FFF Function ControlFCR_0x4000 08000x4000 0BFF"},{"location":"memory-register-mapping-access/#error-correction-coding-ecc-module","title":"Error Correction Coding (ECC) Module","text":"<p>This device features an Error Correction Coding (ECC) module that helps ensure data integrity by detecting and correcting bit corruption of the system RAM0 (sysram0) memory array. More specifically, the ECC module is a single error-correcting, double error detecting (SEC-DED). It corrects any single bit flip, detects two bit errors, and features a transparent zero wait state operation for reads.</p> <p>The ECC works by creating check bits for all data written to sysram0. These check bits are then stored along with the data. During a read, both the data and check bits are used to determine if one or more bits have become corrupt. If a single bit has been corrupted, this can be corrected. If two bits have been corrupted, it is detected but not corrected.</p> <p>If only one bit is determined to be corrupt, reads contain the \"corrected\" value. Reading memory does not correct the error value stored at the read memory location. It is up to the software to determine the appropriate time and method to write the correct data to memory. It is strongly recommended that the software correct the memory as soon as possible to minimize the chance of a second bit from becoming corrupt, resulting in data loss. Since ECC error checking occurs only during a read operation, it is recommended that the application periodically reads critical memory so that errors can be identified and corrected.</p>"},{"location":"memory-register-mapping-access/#sram","title":"SRAM","text":"<p>A check bit RAM is used to store sysram0's check bits, enabling ECC SEC-DED for sysram0. The check bit RAM is not mapped to the user memory space and is unavailable for application usage.</p>"},{"location":"memory-register-mapping-access/#limitations","title":"Limitations","text":"<p>Any read from non-initialized memory can trigger an ECC error since the random check bits most likely do not match the random data bits contained in the memory. Writing sysram0 to all zeroes before enabling ECC functionality can prevent this at the expense of the time required. To zeroize sysram0, write GCR_MEMZ.ram0 to 1.</p>"},{"location":"system-power-clocks-reset/","title":"System, Power, Clocks, Reset","text":"<p>Different peripherals and subsystems use several clocks. These clocks are highly configurable by software, allowing developers to select the combination of application performance and power savings required for the target systems. Support for selectable core operating voltage is provided, enabling optimal timing access to the internal memories.</p>"},{"location":"system-power-clocks-reset/#oscillator-sources","title":"Oscillator Sources","text":""},{"location":"system-power-clocks-reset/#100mhz-internal-primary-oscillator-ipo","title":"100MHz Internal Primary Oscillator (IPO)","text":"<p>The MAX78000 includes a 100MHz internal high-speed oscillator, referred to in this document as the internal primary oscillator (IPO). The IPO is the highest frequency oscillator and draws the most power.</p> <p>The IPO can optionally be powered down in LPM by setting the GCR_PM.ipo_pd field to 1.</p> <p>The IPO can be selected as the SYS_OSC. Use the IPO as the SYS_OSC by performing the following steps:</p> <ol> <li>Enable the IPO by setting GCR_CLKCTRL.ipo_en to 1.</li> <li>Wait until the GCR_CLKCTRL.ipo_rdy field reads 1, indicating the IPO is operating.</li> <li>Set GCR_CLKCTRL.sysclk_sel to 4.</li> <li>Wait until the GCR_CLKCTRL.sysclk_rdy field reads 1. The IPO is now operating as the SYS_OSC.</li> </ol>"},{"location":"system-power-clocks-reset/#60mhz-internal-secondary-oscillator-iso","title":"60MHz Internal Secondary Oscillator (ISO)","text":"<p>The ISO is a low-power internal secondary oscillator that is the power-on reset default SYS_OSC. The ISO is automatically selected as SYS_OSC after a system reset or POR.</p> <p>The following steps show how to enable the ISO and select it as the SYS_OSC.</p> <ol> <li>Enable the ISO by setting GCR_CLKCTRL.iso_en to 1.</li> <li>Wait until the GCR_CLKCTRL.iso_rdy field reads 1, indicating the ISO is operating.</li> <li>Set GCR_CLKCTRL.sysclk_sel to 0.</li> <li>Wait until the GCR_CLKCTRL.sysclk_rdy field reads 1. The ISO is now operating as the SYS_OSC.</li> </ol>"},{"location":"system-power-clocks-reset/#8khz-30khz-internal-nano-ring-oscillator-inro","title":"8kHz-30kHz Internal Nano-Ring Oscillator (INRO)","text":"<p>The INRO is an ultra-low-power internal oscillator that can be selected as the SYS_OSC. The INRO is always enabled and cannot be disabled by software.</p> <p>The frequency of this oscillator is configurable to 8kHz, 16kHz, or 30kHz. Use the TRIMSIR_INRO.lpclksel field to select the desired frequency. On a POR or system reset, the frequency defaults to 30kHz.</p> <p>The following steps show how to set the INRO as the SYS_OSC.</p> <ol> <li>Verify the GCR_CLKCTRL.inro_rdy field reads 1.</li> <li>Set GCR_CLKCTRL.sysclk_sel to 3.</li> <li>Wait until the GCR_CLKCTRL.sysclk_rdy field reads 1. The INRO is now operating as the SYS_OSC.</li> </ol>"},{"location":"system-power-clocks-reset/#73728mhz-internal-baud-rate-oscillator-ibro","title":"7.3728MHz Internal Baud Rate Oscillator (IBRO)","text":"<p>The IBRO is a very low-power internal oscillator that can be selected as SYS_OSC. The INRO can optionally be used as a dedicated baud rate clock for the UARTs. The INRO is useful if the selected SYS_OSC does not accurately generate a desired UART baud rate.</p> <p>The following steps show how to enable the IBRO and select it as the SYS_OSC.</p> <ol> <li>Wait until the GCR_CLKCTRL.ibro_rdy field reads 1, indicating the IBRO is operating.</li> <li>Set GCR_CLKCTRL.sysclk_sel to 5.</li> <li>Wait until the GCR_CLKCTRL.sysclk_rdy field reads 1. The IBRO is now operating as the SYS_OSC.</li> </ol>"},{"location":"system-power-clocks-reset/#32768khz-external-real-time-clock-oscillator-ertco","title":"32.768kHz External Real-Time Clock Oscillator (ERTCO)","text":"<p>The ERTCO is an extremely low-power internal oscillator that can be selected as the SYS_OSC. The ERTCO can optionally use a 32.768kHz input clock or an 8kHz independent nano-ring oscillator instead of an external crystal. The internal 32.768kHz clock is available as an output on GPIO P3.1 as alternate function 1 (SQWOUT).</p> <p>This oscillator is the default clock for the real-time clock (RTC). If the RTC is enabled, the ERTCO is enabled automatically, independent of the selection of the SYS_OSC. The ERTCO is disabled on a POR or system reset.</p> <p>The following steps show how to enable the ERTCO and select it as the SYS_OSC.</p> <ol> <li>Enable the ERTCO by setting GCR_CLKCTRL.ertco_en to 1.</li> <li>Wait until the GCR_CLKCTRL.ertco_rdy field reads 1, indicating the ERTCO is operating.</li> <li>Set GCR_CLKCTRL.sysclk_sel to 6.</li> <li>Wait until the GCR_CLKCTRL.sysclk_rdy field reads 1. The ERTCO is now operating as the SYS_OSC.</li> </ol>"},{"location":"system-power-clocks-reset/#system-oscillator-sys_osc","title":"System Oscillator (SYS_OSC)","text":"<p>The MAX78000 supports multiple clock sources as the SYS_OSC. The selected SYS_OSC is the clock source for most internal blocks. Each oscillator, description, and nominal frequency are shown in Table 4-1. An external clock source, EXT_CLK, is supported on P0.3, alternate function 1. Each of the oscillators/clocks is described in detail in section Oscillator Sources.</p> <p>Table 4-1: Available System Oscillators </p> Oscillator/Clock Description Nominal Frequency IPO Internal Primary Oscillator 100MHz ISO Internal Secondary Oscillator 60MHz INRO Internal Nano-Ring Oscillator Configurable 8kHz, 16kHz, or 30kHz IBRO Internal Baud Rate Oscillator 7.3728MHz ERTCO External Real-Time Clock Oscillator 32.768kHz EXT_CLK External Clock Up to 80MHz"},{"location":"system-power-clocks-reset/#system-oscillator-selection","title":"System Oscillator Selection","text":"<p>Set the system oscillator using the GCR_CLKCTRL.sysclk_sel field. Before selecting an oscillator as the system oscillator, the oscillator source must first be enabled and ready. See each oscillator source\u2019s detailed description for the required steps to enable the oscillator and select it as the system oscillator.</p> <p>When the GCR_CLKCTRL.sysclk_sel is modified, hardware clears the GCR_CLKCTRL.sysclk_rdy field, and there is a delay until the switchover is complete. When the switchover to the selected SYS_OSC is complete, the GCR_CLKCTRL.sysclk_rdy field is set to 1 by hardware. The application software must verify that the switchover is complete before continuing operation.</p>"},{"location":"system-power-clocks-reset/#system-clock-sys_clk","title":"System Clock (SYS_CLK)","text":"<p>The selected SYS_OSC is the input to the system oscillator divider to generate the system clock (SYS_CLK). The system clock divider divides the selected SYS_OSC by the GCR_CLKCTRL.sysclk_div field, as shown in Equation 4-1.</p> <p>Equation 4-1: System Clock Scaling </p> <p>SYS_CLK = SYS_OSC / 2<sup>sysclk_div</sup></p> <p>GCR_CLKCTRL.sysclk_div is selectable from 0 to 7, resulting in divisors of 1, 2, 4, 8, 16, 32, 64 or 128.</p> <p>SYS_CLK drives the Arm core, the RV32 core, and all AHB masters in the system. SYS_CLK generates the following internal clocks as shown below:</p> <ul> <li>AHB Clock<ul> <li>HLCK = SYS_CLK</li> </ul> </li> <li>APB Clock<ul> <li>PCLK = SYS_CLK / 2</li> </ul> </li> </ul> <p>The RTC uses the ERTCO for its clock source. Optionally, the RTC can run using an internal dedicated 8kHz nano-ring oscillator. See the Real-Time Clock (RTC) chapter for details on using this 8kHz nano-ring oscillator for the RTC.</p> <p>All oscillators are reset to their POR reset default state during: - Power-On Reset - System Reset</p> <p>Oscillator settings are not reset during: - Soft Reset - Peripheral Reset</p> <p>Table 4-2 shows each oscillator\u2019s enabled state for each type of reset source in the MAX78000. Note: A Watchdog Timer Reset performs a System Reset.</p> <p>Table 4-2: Reset Sources and Effect on Oscillator and System Clock </p> Reset Source Oscillator POR System Soft Peripheral IPO Disabled Disabled Retains State Retains State ISO Enabled Enabled Retains State Retains State IBRO Enabled Enabled Enabled Enabled INRO Enabled Enabled Enabled Enabled ERTCO Disabled Disabled Retains State Retains State System Clock(SYS_OSC) Source ISO ISO Retains State Retains State <p>Figure 4-1: MAX78000 Clock Block Diagram shows a high-level diagram of the MAX78000 clock tree. Figure 4-1: MAX78000 Clock Block Diagram</p>"},{"location":"system-power-clocks-reset/#operating-modes","title":"Operating Modes","text":"<p>The MAX78000 includes multiple operating modes and the ability to fine-tune power options to optimize performance and power. The system supports the following operating modes:</p> <ul> <li>ACTIVE</li> <li>SLEEP</li> <li>Low-Power Mode (LPM)</li> <li>Micro Power Mode (UPM)</li> <li>STANDBY</li> <li>BACKUP</li> <li>Power Down Mode (PDM)</li> </ul>"},{"location":"system-power-clocks-reset/#active-mode","title":"ACTIVE Mode","text":"<p>In this mode, both the CM4 and the RV32 cores can execute software, and all digital and analog peripherals are available on demand. Dynamic clocking disables peripheral not in use, providing the optimal mix of high performance and low power consumption. The CM4 has access to all System RAM by default. The RV32 has access to sysram2 and sysram3 and can be optionally configured to have exclusive access to these RAMs. Additionally, sysram3 can be configured as a unified internal cache controller for the RV32 allowing simultaneous data access and code execution for the CM4 and RV32 from the internal flash memory.</p> <p>Each of the peripherals can be individually enabled during active mode or powered down. The CNN and each of the four CNNx16_n Processor Arrays and their associated memories can be powered down or set to active mode.</p>"},{"location":"system-power-clocks-reset/#low-power-modes","title":"Low-Power Modes","text":""},{"location":"system-power-clocks-reset/#sleep","title":"SLEEP","text":"<p>This mode consumes less power but wakes faster because the clocks can optionally be enabled. The device status is as follows:</p> <ul> <li>The CM4 (CPU0) is sleeping</li> <li>The RV32 (CPU1) is sleeping</li> <li>The CNN is optionally available for use</li> <li>Each of the four CNNx16_n quadrants is individually configurable for power down</li> <li>Standard DMA is available for use</li> <li>All peripherals are on unless explicitly disabled before entering SLEEP</li> </ul>"},{"location":"system-power-clocks-reset/#entering-sleep","title":"Entering SLEEP","text":"<p>Entering SLEEP requires both the CM4 and RV32 to cooperate to enter SLEEP. Synchronization is necessary for deterministic entry into SLEEP. Two methods are described below, allowing either core to request entry into SLEEP. Both methods use the semaphore peripheral interrupt to communicate between the cores.</p> <p>If the RV32 is driving entry to SLEEP, the RV32 notifies the CM4 of a request to enter SLEEP using Multiprocessor Communications. The CM4 receives the notification and then sends confirmation through the semaphore peripheral to the RV32. The CM4 should then enter SLEEP by setting the SCR.sleepdeep field to 0 and performing a WFI or WFE instruction. The RV32 should then enter SLEEP by performing a WFI instruction or by setting GCR_PM.mode to 1, followed by two NOP instructions.</p> <p>Alternatively, the CM4 can initiate the request to enter SLEEP by sending the request to the RV32 using Multiprocessor Communications. The RV32 confirms the request through Multiprocessor Communications and performs a WFI instruction followed by two NOP instructions. The CM4 should then enter SLEEP by setting SCR.sleepdeep to 0 and performing a WFI or WFE instruction or by setting GCR_PM.mode to 1.</p> <p>Figure 4-2: SLEEP Mode Clock Control</p>"},{"location":"system-power-clocks-reset/#lpm","title":"LPM","text":"<p>This mode is suitable for running the RV32 processor to collect and move data from enabled peripherals. The device status is a follows:</p> <ul> <li>The CM4, sysram0, and sysram1 are in state retention</li> <li>The CNN quadrants and memory are active and configurable.</li> <li>The RV32 can access the SPI, UARTS, Timers, I2C, 1-Wire, Timers, Pulse Train Engine, I2S, CRC, AES, TRNG, Comparators, as well as sysram2 and sysram3. Sysram3 can be configured to operate as the RV32 unified instruction cache</li> <li>The transition from LPM to ACTIVE is faster than the transition from BACKUP to ACTIVE because system initialization is not required</li> <li>The DMA is in state retention mode</li> <li>PWRSEQ_GP0 and PWRSEQ_GP1 registers retain state</li> <li>Choose the system PCLK or ISO as the clock source for the RV32 and all peripherals <ul> <li>PWRSEQ_LPCN.lpmclksel defaults to use ISO during LPM. Setting this field to 1 uses the PCLK</li> </ul> </li> <li>The following oscillators are powered down by default, but can be configured by software to remain active:<ul> <li>ISO</li> <li>IPO</li> <li>ERTCO</li> <li>INRO</li> </ul> </li> <li>The following oscillator is enabled:<ul> <li>IBRO</li> </ul> </li> </ul>"},{"location":"system-power-clocks-reset/#entering-lpm","title":"Entering LPM","text":"<p>Entry into LPM should be managed between the two cores using Multiprocessor Communications to ensure both cores are in a known state when entering LPM.</p> <p>When the CM4 puts itself into deep sleep, the device automatically enters LPM, and hardware sets the GCR_PM.mode to LPM. To place the CM4 in LPM mode in software, perform the following instructions.</p> <p>SCR.sleepdeep = 1;  // deep sleep mode enabled WFI (or WFE);   // Enter deep sleep mode</p> <p>If the RV32 requests the CM4 to enter LPM mode through Multiprocessor Communications and the CM4 enters SLEEP instead, by setting SCR.sleepdeep to 0 and performing a WFI or WFE instruction, the RV32 can put the device into LPM by directly setting the GCR_PM.mode field to LPM (8).</p> <p>Note: The device immediately enters LPM when the GCR_PM.mode field is set to LPM. If the CM4 is not in a known state, issues may occur when exiting LPM.</p> <p>Figure 4-3: LPM Clock and State Retention Diagram</p>"},{"location":"system-power-clocks-reset/#upm","title":"UPM","text":"<p>This mode is used for extremely low power consumption while using a minimal set of peripherals to provide wake-up capability. The device status during UPM is:</p> <ul> <li>Both CM4 and RV32 are state retained.</li> <li>System state and all system RAM are retained</li> <li>CNN quadrants are optionally powered off</li> <li>CNN memory provides selectable retention</li> <li>The GPIO pins retain their state</li> <li>All non-UPM peripherals are state retained</li> <li>The following oscillators are powered down:<ul> <li>IPO</li> <li>ISO</li> </ul> </li> <li>The following oscillators are enabled:<ul> <li>IBRO</li> <li>ERTCO, firmware configurable</li> <li>INRO, firmware configurable</li> </ul> </li> <li>The following UPM peripherals are available for use to wake the device:<ul> <li>LPUART0</li> <li>LPTMR0</li> <li>LPTMR1</li> <li>LPWDT0</li> <li>LPCOMP0-LPCOMP3</li> <li>GPIO</li> </ul> </li> </ul>"},{"location":"system-power-clocks-reset/#entering-upm","title":"Entering UPM","text":"<p>Entering UPM mode requires both the CM4 and RV32 to cooperate to enter UPM mode. Synchronization is necessary for deterministic entry into UPM. Two methods are described below, allowing either core to request entry into UPM and ensuring deterministic entry. Both methods use the Semaphore peripheral interrupt to communicate between the cores.</p> <p>If the RV32 is driving entry to UPM, the RV32 notifies the CM4 of a request to enter UPM using Multiprocessor Communications. The CM4 receives the notification and then sends a confirmation through the semaphore peripheral to the RV32. The CM4 should then enter SLEEP by setting SCR.sleepdeep to 0 and performing a WFI or WFE instruction. The RV32 sets the GCR_PM.mode to UPM, followed by two NOP instructions, and the device immediately enters UPM.</p> <p>Alternatively, the CM4 can initiate the request to enter UPM by sending the request to the RV32 using Multiprocessor Communications. The RV32 confirms the request through Multiprocessor Communications and performs a WFI instruction, followed by two NOP instructions. The CM4 then sets the GCR_PM.mode to UPM, and the device immediately enters UPM.</p> <p>Figure 4-4: UPM Clock and State Retention Block Diagram</p>"},{"location":"system-power-clocks-reset/#standby","title":"STANDBY","text":"<p>This mode is used to maintain the system operation while keeping time with the RTC. The device status is as follows:</p> <ul> <li>Both CM4 and RV32 are state retained.</li> <li>System state and all system RAM is retained</li> <li>CNN quadrants are powered off</li> <li>CNN memory provides selectable retention (optional state retention)</li> <li>GPIO pins retain their state</li> <li>All peripherals retain state</li> <li>The following oscillators are powered down:<ul> <li>IPO</li> <li>ISO</li> <li>IBRO</li> </ul> </li> <li>The following oscillators are enabled:<ul> <li>ERTCO, firmware configurable</li> <li>INRO</li> </ul> </li> </ul>"},{"location":"system-power-clocks-reset/#entering-standby","title":"Entering STANDBY","text":"<p>Entering STANDBY requires both the CM4 and RV32 to enter STANDBY mode. Synchronization is necessary for deterministic entry into STANDBY. Two methods are described below, allowing either core to request entry into STANDBY and ensuring deterministic entry. Both methods use the semaphore peripheral interrupt to communicate between the cores.</p> <p>If the RV32 is driving entry to STANDBY, the RV32 notifies the CM4 of a request to enter STANDBY using Multiprocessor Communications. The CM4 receives the notification and then sends a confirmation through the semaphore peripheral to the RV32. The CM4 should then enter SLEEP by setting SCR.sleepdeep to 0 and performing a WFI or WFE instruction. The RV32 sets the GCR_PM.mode to STANDBY, followed by two NOP instructions, and the device immediately enters into STANDBY.</p> <p>Alternatively, the CM4 can initiate the request to enter STANDBY by sending the request to the RV32 using Multiprocessor Communications. The RV32 confirms the request through Multiprocessor Communications and performs a WFI instruction followed by two NOP instructions. The CM4 then sets the GCR_PM.mode to STANDBY, and the device immediately enters STANDBY.</p> <p>Figure 4-5: STANDBY Mode Clock and State Retention Block Diagram</p>"},{"location":"system-power-clocks-reset/#backup","title":"BACKUP","text":"<p>This mode is used to maintain the System RAM. The device status is as follows:</p> <ul> <li>CM4 and RV32 are powered off.</li> <li>Sysram0, sysram1, sysram2, and sysram3 can be independently configured for state retention, as shown in Table 4-3.</li> <li>User-configurable CNN memory retention</li> <li>All peripherals are powered off</li> <li>The following oscillators are powered down:<ul> <li>IPO</li> <li>ISO</li> <li>IBRO</li> <li>INRO</li> </ul> </li> <li>The following oscillators are enabled:<ul> <li>ERTCO (The RTC peripheral can be turned off, but not the oscillator)</li> </ul> </li> </ul> <p>Table 4-3 System RAM Retention in BACKUP Mode</p>"},{"location":"system-power-clocks-reset/#entering-backup","title":"Entering BACKUP","text":"<p>Entering BACKUP mode does not require synchronization between the RV32 and CM4 cores. However, it is recommended that Multiprocessor Communications are used to ensure both cores are aware of entry into BACKUP and complete any memory transactions before entry.</p> <p>Either core can set GCR_PM.mode to BACKUP, and the device immediately enters BACKUP.</p> <p>Figure 4-6: BACKUP Mode Clock and State Retention Block Diagram</p>"},{"location":"system-power-clocks-reset/#pdm","title":"PDM","text":"<p>This mode is used during product level distribution and storage. The device status is as follows:</p> <ul> <li>The CM4 and RV32 are powered off</li> <li>All peripherals and all RAMs are powered down</li> <li>All oscillators are powered down</li> <li>There is no data retention in this mode, but values in the flash are preserved</li> <li>V<sub>REGI</sub> POR voltage monitor is operational.</li> <li>Exit from PDM is possible through an external reset (RSTN) or a wake-up event using either P3.0 or P3.1 if configured.</li> </ul>"},{"location":"system-power-clocks-reset/#entering-pdm","title":"Entering PDM","text":"<p>Entering PDM does not require synchronization between the RV32 and CM4 cores. However, it is recommended that Multiprocessor Communications is used to ensure both cores are aware of entry into PDM and complete any flash memory transactions.</p> <p>Either core can set GCR_PM.mode to PDM, and the device immediately enters PDM.</p> <p>Figure 4-7: PDM Clock and State Retention Block Diagram</p>"},{"location":"system-power-clocks-reset/#wake-up-sources-for-each-operating-mode","title":"Wake-Up Sources for Each Operating Mode","text":"<p>In all operating modes other than ACTIVE, wake-up sources are required to re-enter ACTIVE operation. Table 4-4 shows available wake-up sources for each operating mode of the MAX78000.</p> <p>Note: Each wake-up source must be enabled individually except for External Reset, which is hardware controlled.</p> <p>Table 4-4: Wake-Up Sources for Each Operating Mode in the MAX78000 </p> Operating Mode Any Peripheral Interrupts External Reset RV32 CNN CNN FIFO SPI1 SPI0 Any Peripheral Interrupts I2C I2C2 I2C1 I2C0 LPUART0 (UART3) UART2 UART1 UART0 LPUART0 (TMR5) LPUART0 (TMR4) TMR3 TMR2 TMR1 TMR0 LPWDT0 (WDT1) WDT0 LPCOMP3 LPCOMP2 LPCOMP1 COMP0 RTC WUT GPIO3 GPIO2 GPIO1 GPIO0 SLEEP xxxx\uf0fc\uf0fc\uf0fc\uf0fc \uf0fc\uf0fc\uf0fcx\uf0fc\uf0fc\uf0fc\uf0fc \uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc \uf0fc\uf0fc\uf0fcx\uf0fc\uf0fcx LPM \uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc \uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc \uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc \uf0fc\uf0fc\uf0fc\uf0fc\uf0fc UPM \uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc \uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc STANDBY \uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc BACKUP \uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc\uf0fc PDM \uf0fc\uf0fc"},{"location":"system-power-clocks-reset/#device-resets","title":"Device Resets","text":"<p>Four device resets are available:</p> <ul> <li>Peripheral Reset</li> <li>Soft Reset</li> <li>System Reset</li> <li>Power-On Reset</li> </ul> <p>On completion of any of the four reset cycles, all peripherals are reset. On completion of any reset cycle, HCLK and PCLK are operational, the CPU core receives clocks and power, and the device is in ACTIVE. Program execution begins at the reset vector address.</p> <p>The contents of the always-on domain (AoD) are reset only on power-cycling VCOREA, VCOREB, VDDA, VDDIOH, or VREGI.</p> <p>The on-chip peripherals can also be reset to their POR default state using the two reset registers, GCR_RST0 and GCR_RST1.</p> <p>Table 4-5 shows the effects of each reset type on each of the operating modes.</p> <p>Table 4-5: Reset and Low-Power Mode Effects</p>"},{"location":"system-power-clocks-reset/#peripheral-reset","title":"Peripheral Reset","text":"<p>Peripheral reset resets all peripherals. The CPU retains its state. The GPIO, watchdog timers, AoD, RAM retention, and general control registers (GCR), including the clock configuration, are unaffected.</p> <p>To start a peripheral reset, set GCR_RST0.periph to 1. The reset is completed immediately upon setting GCR_RST0.periph to 1.</p>"},{"location":"system-power-clocks-reset/#soft-reset","title":"Soft Reset","text":"<p>A soft reset is the same as a peripheral reset except that it also resets the GPIO to its POR state.</p> <p>To perform a soft reset, set GCR_RST0.soft to 1. The reset occurs immediately upon setting GCR_RST0.soft to 1.</p>"},{"location":"system-power-clocks-reset/#system-reset","title":"System Reset","text":"<p>A system reset is the same as a soft reset, except it also resets all GCR, resetting the clocks to their POR default state. The CPU state is reset, as well as the watchdog timers. The AoD and RAM are unaffected.</p> <p>A watchdog timer reset event initiates a system reset. To start a system reset, set GCR_RST0.sys to 1.</p>"},{"location":"system-power-clocks-reset/#power-on-reset","title":"Power-On Reset","text":"<p>A POR resets everything in the device to its default state. A POR results from V<sub>COREA</sub>, V<sub>COREB</sub>, V<sub>DDA</sub>, or V<sub>REGI</sub> falling below their reset voltage level. Refer to the MAX78000 data sheet for details of the reset voltage levels.</p>"},{"location":"system-power-clocks-reset/#unified-internal-cache-controllers","title":"Unified Internal Cache Controllers","text":"<p>The MAX78000 includes two unified internal cache controllers. ICC0 is the cache controller used for the CM4. ICC1, if enabled, is dedicated to the RV32 core. ICC1 uses sysram3 as the cache memory. If ICC1 is enabled, sysram3 is not accessible as SRAM (address range 0x2001 C000 to 0x2001 FFFF).</p> <p>Both caches, ICC0 and ICC1, include a line buffer, tag RAM, and a 16KB 2-way set associative RAM when enabled.</p>"},{"location":"system-power-clocks-reset/#enabling-the-internal-cache-controllers","title":"Enabling the Internal Cache Controllers","text":"<p>Enabling ICC1 for use as the cache controller for the RV32 requires using sysram3 as the cache memory. Note: The contents of sysram3 are lost when ICC1 is enabled, and sysram3 is not accessible for data reads or writes as part of the memory map. Note: Before enabling ICC1 as a cache controller, sysram3 should be zeroized.</p> <p>Perform the following steps to enable each ICC:</p> <ol> <li>Set the ICCn_CTRL.en to 0, ensuring the cache is invalidated when enabled.</li> <li>Set ICCn_CTRL.en to 1.</li> <li>Read ICCn_CTRL.rdy until it returns 1.</li> <li>Zeroize the ICC instance by setting GCR_MEMZ.icc0 or GCR_MEMZ.icc1 to 1.</li> </ol>"},{"location":"system-power-clocks-reset/#disabling-the-icc","title":"Disabling the ICC","text":"<p>Disable an ICC instance by setting ICCn_CTRL.en to 0.</p> <p>To use sysram3 as data RAM, first, disable the ICC1 instance as described above. When ICC1 is disabled, sysram3 is accessible as data RAM by both the CM4 and RV32 controllers unless sysram3 is configured for exclusive access by the RV32 core only.</p>"},{"location":"system-power-clocks-reset/#invalidating-the-icc-cache-and-tag-ram","title":"Invalidating the ICC Cache and Tag RAM","text":"<p>Invalidate the contents of a specific ICC instance by setting the ICCn_INVALIDATE register to 1. Once invalidated, the system flushes the cache. Read the ICCn_CTRL.rdy field until it returns 1 to determine when the flush is completed.</p>"},{"location":"system-power-clocks-reset/#flushing-the-icc","title":"Flushing the ICC","text":"<p>Flush ICC0 using the system configuration register (GCR_SYSCTRL). Set GCR_SYSCTRL.icc0_flush to 1 to immediately flush the contents of the 16KB cache and tag RAM.</p> <p>Flush ICC1 using the RV32 Control Register (FCR_URVCTRL). Set FCR_URVCTRL.icc1_flush to 1 to immediately flush the contents of the 16KB cache and tag RAM.</p>"},{"location":"system-power-clocks-reset/#internal-cache-control-registers-icc","title":"Internal Cache Control Registers (ICC)","text":"<p>See Table 3-3 for the base address of this peripheral/module. See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Table 4-6: Instruction Cache Controller Register Summary </p> Offset Register Name [0x0000] ICCn_INFO Cache ID Register [0x0004] ICCn_SZ Cache Memory Size Register [0x0100] ICCn_CTRL Instruction Cache Control Register [0x0700] ICCn_INVALIDATE Instruction Cache Controller Invalidate Register"},{"location":"system-power-clocks-reset/#icc0-register-details","title":"ICC0 Register Details","text":"<p>Table 4-7: ICC0 Cache Information Register </p> ICC0 Cache Information ICCn_INFO [0x0000] Bits Name Access Reset Description 31:16 - RO 0 Reserved 15:10 id R - Cache IDThis field returns the ID for the cache instance. 9:6 partnum R - Cache Part NumberThis field returns the part number indicator for the cache instance. 5:0 relnum R - Cache Release NumberThis field returns the release number for the cache instance. <p>Table 4-8: ICC0 Memory Size Register </p> ICC0 Memory Size ICCn_SZ [0x0004] Bits Name Access Reset Description 31:16 mem R - Addressable Memory SizeThis field indicates the size of addressable memory by the cache controller instance in 128KB units. 15:0 cch R - Cache SizeThis field returns the size of the cache RAM in 1KB units.  16: 16KB Cache RAM <p>Table 4-9: ICC0 Cache Control Register </p> ICC0 Cache Control ICCn_CTRL [0x0100] Bits Name Access Reset Description 31:17 - R/W - Reserved 16 rdy R - ReadyThis field is cleared by hardware anytime the cache as a whole is invalidated (including a POR). Hardware automatically sets this field to 1 when the invalidate operation is complete, and the cache is ready. <p>0: Cache invalidation in process.</p> <p>1: Cache is ready.</p>          *Note: While this field reads 0, the cache is bypassed, and reads come directly from the line fill buffer.*     15:1 - R/W - Reserved 0 en R/W 0 Cache EnableSet this field to 1 to enable the cache. Setting this field to 0 invalidates the cache contents, and the line fill buffer handles all reads.  <p>0: Disable</p> <p>1: Enable</p> <p>Table 4-10: ICC0 Invalidate Register </p> ICC0 Invalidate ICCn_INVALIDATE [0x0700] Bits Name Access Reset Description 31:0 invalid W - InvalidateWriting any value to this register invalidates the cache."},{"location":"system-power-clocks-reset/#ram-memory-management","title":"RAM Memory Management","text":"<p>This device has many features for managing the on-chip RAM. The on-chip RAM includes the data RAM, the unified cache controllers (ICC0 and ICC1), the CNN RAM, and the peripheral FIFOs.</p>"},{"location":"system-power-clocks-reset/#on-chip-cache-management","title":"On-Chip Cache Management","text":"<p>The MAX78000 includes two unified internal cache controllers for code and data fetches from the flash memory. The caches can be enabled, disabled, zeroized, and flushed. See section Unified Internal Cache Controller for details.</p>"},{"location":"system-power-clocks-reset/#ram-zeroization","title":"RAM Zeroization","text":"<p>The GCR memory zeroize register, GCR_MEMZ, allows clearing memory for software or security reasons. Zeroization writes all zeros to the specified memory.</p> <p>The following SRAM memories can be zeroized:</p> <ul> <li>Each of the System RAMs can be individually zeroized by setting the respective GCR_MEMZ bit:<ul> <li>GCR_MEMZ.ram0</li> <li>GCR_MEMZ.ram0ecc</li> <li>GCR_MEMZ.ram1</li> <li>GCR_MEMZ.ram2</li> <li>GCR_MEMZ.ram3</li> </ul> </li> <li>ICC0 16KB Cache</li> <li>GCR_MEMZ.icc0</li> <li>ICC1 16KB Cache, if enabled<ul> <li>GCR_MEMZ.icc1</li> <li>Each of the CNNx16n processor arrays supports zeroizing the tornado RAM, mask RAM, bias RAM, and data SRAM:</li> <li>CNNx16_n_TEST.tramz set to 1 to zero, read CNNx16_n_TEST.tallzdone until 1 for completion</li> <li>CNNx16_n_TEST.mramz set to 1 to zero, read CNNx16_n_TEST.mallzdone until 1 for completion</li> <li>CNNx16_n_TEST.bramz set to 1 to zero, read CNNx16_n_TEST.ballzdone until 1 for completion</li> <li>CNNx16_n_TEST.sramz set to 1 to zero, read CNNx16_n_TEST.sallzdone until 1 for completion</li> </ul> </li> </ul>"},{"location":"system-power-clocks-reset/#miscellaneous-control-registers-mcr","title":"Miscellaneous Control Registers (MCR)","text":"<p>See Table 3-3 for the base address of this peripheral/module. See Table 1-1 for an explanation of the read and write access of each field. Unless specified otherwise, all fields are reset on a system reset, soft reset, POR, and the peripheral-specific resets.</p> <p>Table 4-11: Miscellaneous Control Register Summary </p> Offset Register Name Access Name [0x0000] MCR_ECCEN R/W Error Correction Coding Enable Register [0x0004] MCR_IPO_MTRIM R/W IPO Manual Trim Register [0x0008] MCR_OUTEN R/W Miscellaneous Output Enable Register [0x000C] MCR_CMP_CTRL R/W Comparator Control Register [0x0010] MCR_CTRL R/W Miscellaneous Control Register [0x0020] MCR_GPIO3_CTRL R/W GPIO3 Pin Control Register"},{"location":"system-power-clocks-reset/#miscellaneous-control-register-details","title":"Miscellaneous Control Register Details","text":"<p>Table 4-12: Error Correction Coding Enable Register </p> Error Correction Coding Enable MCR_ECCEN [0x0000] Bits Name Access Reset Description 31:1 - RO 0 Reserved 0 ram0 R/W 0 System RAM 0 ECC EnableSet this field to 1 to enable ECC for *sysram0*. <p>0: Disabled</p> <p>1: Enabled</p> <p>Table 4-13: IPO Manual Register </p> IPO Manual Trim MCR_IPO_MTRIM [0x0004] Bits Name Access Reset Description 31:9 - R0 0 Reserved 8 trim_range R/W 0 Trim Range SelectIf this bit is set to 1, the value loaded into the MCR_IPO_MTRIM.mtrim field must be greater than the trim setting in the TRIMSIR_IPOLO.ipo_limitlo field. If this bit is set to 0, the value loaded into the MCR_IPO_MTRIM.mtrim field must be less than the trim setting in the TRIMSIR_CTRL.ipo_limithi field.          <p>0: MCR_IPO_MTRIM.mtrim &lt; TRIMSIR_IPOLO.ipo_limitlo</p> <p>1: MCR_IPO_MTRIM.mtrim &gt; TRIMSIR_CTRL.ipo_limithi</p> 7:0 mtrim R/W 0x04 Manual Trim Value     Set this value to the desired manual trim based on the value set in MCR_IPO_MTRIM.trim_range.     If MCR_IPO_MTRIM.trim_range is 0, the value in this field must be less than the value in TRIMSIR_IPOLO.ipo_limitlo.     If MCR_IPO_MTRIM.trim_range is 1, the value in this field must be greater than the value in TRIMSIR_CTRL.ipo_limithi.      <p>Table 4-14: Output Enable Register </p> Output Enable MCR_OUTEN [0x0008] Bits Name Access Reset Description 31:2 - RO 0 Reserved 1 pdown_out_en R/W 0 Power Down Output Enable on P3.0Set this field to 1 to enable the power down output, P3.0 AF1 (PDOWN). PDOWN is active in BACKUP and STANDBY. <p>0: PDOWN output not enabled on P3.0</p> <p>1: PDOWN output is enabled on P3.0</p> 0 sqwout_en R/W 0 Square Wave Output Enable on P3.1 (SQWOUT)Set this field to 1 to enable the square wave output on P3.1 AF1 (SQWOUT). <p>0: Square wave output not enabled on P3.1.</p> <p>1: Square wave output enabled on P3.1.</p> <p>Table 4-15: Comparator 0 Control Register </p> Comparator 0 Control MCR_CMP_CTRL [0x000C] Bits Name Access Reset Description 31:16 - RO 0 Reserved 15 if R/W1C 0 Comparator 0 Interrupt FlagThis field is set to 1 by hardware when the comparator output changes to the active state as set using the MCR_CMP_CTRL.pol field. Write 1 to clear this flag. <p>0: No interrupt</p> <p>1: Interrupt occurred</p> 14 out RO * Comparator 0 OutputThis field is the comparator output state. <p>0: Output low</p> <p>1: Output high</p> 13-7 - RO * Reserved 6 int_en R/W 0 Comparator 0 Interrupt EnableSet this field to 1 to enable the interrupt for comparator 0. <p>0: Interrupt disabled</p> <p>1: Interrupt enabled</p> 5 pol R/W 0 Comparator 0 Interrupt Polarity SelectSet this field to select the polarity of the output change that generates a comparator 3 interrupt. <p>0: Interrupt occurs from a transition from low to high</p> <p>1: Interrupt occurs from a transition from high to low</p> 4:1 - RO 0 Reserved 0 en R/W 0 Comparator 0 EnableSet this field to 1 to enable the comparator. <p>0: Comparator disabled</p> <p>1: Comparator enable</p> <p>Table 4-16: Miscellaneous Control Register </p> Miscellaneous Control MCR_CTRL [0x0010] Bits Name Access Reset Description 31:10 - RO 0 Reserved 9 simo_rstd R/W 0 SIMO System Reset DisableIf this field is set, the SIMO is only reset by a POR. When this bit is set, the VSET* stays unchanged when exiting all low-power modes. <p>0: The SIMO is reset by all system resets.</p> <p>1: The SIMO is only reset by a Power-On Reset.</p> 9 simo_rstd R/W 0 SIMO System Reset DisableIf this field is set, the SIMO is only reset by a POR. When this bit is set, the VSET* stays unchanged when exiting all low-power modes. <p>0: The SIMO is reset by all system resets.</p> <p>1: The SIMO is only reset by a Power-On Reset.</p> 8 simo_clkscl_en R/W 0 SIMO Clock Scaling EnableSet this field to 1 to enable dynamic clock scaling to the SIMO based on load current. When enabled, the SIMO clock slows down in low-power modes, reducing current consumption. <p>0: SIMO clock scaling disabled</p> <p>1: SIMO clock scaling enabled</p> 7:4 - DNM 0x01 Reserved 3 ertco_en R/W 0 ERTCO Enable for *LPM* and *UPM*Set this field to 1 to enable the ERTCO in *LPM* and *UPM*. <p>0: ERTCO disabled</p> <p>1: ERTCO enabled</p> 2 inro_en R/W 0 INRO EnableSet this field to 1 to enable the INRO in *LPM* and *UPM*. <p>0: INRO disabled</p> <p>1: INRO enabled</p> 1:0 - RO 0 Reserved"},{"location":"system-power-clocks-reset/#gpio-3-control","title":"GPIO 3 Control","text":"<p>Table 4-17: GPIO3 Pin Control Register </p> GPIO3 Pin Control MCR_GPIO3_CTRL [0x0020] Bits Name Access Reset Description 31:8 - RO 0 Reserved 7 p31_in RO See Description GPIO3 Pin 1 Input StatusRead this field to determine the input status of P3.1. <p>0: Input Low</p> <p>1: Input High</p> 6 p31_pe R/W 0 GPIO3 Pin 1 Pull-up EnableSet this bit to 1 to enable the pullup resistor for P3.1. <p>0: Pull-up Disabled</p> <p>1: Pull-up Enabled</p> 5 p31_oe R/W 0 GPIO3 Pin 1 Output EnableSet this bit to 1 to enable P3.1 for output mode. <p>0: Input mode.</p> <p>1: Output mode enabled.</p> 4 p31_do R/W 0 GPIO3 Pin 1 Data OutputIf *p31_oe* is set to 1, this field is used to control the output state of P3.1. <p>0: Output low if *p31_oe* is 1</p> <p>1: Output high if *p31_oe* is 1.</p> 3 p30_in RO See Description GPIO3 Pin 0 Input StatusRead this field to determine the input status of P3.0. <p>0: Input Low</p> <p>1: Input High</p> 2 p30_pe R/W 0 GPIO3 Pin 0 Pull-up EnableSet this bit to 1 to enable the pullup resistor for P3.0. <p>0: Pull-up Disabled</p> <p>1: Pull-up Enabled</p> 1 p30_oe R/W 0 GPIO3 Pin 0 Output EnableSet this bit to 1 to enable P3.0 for output mode. <p>0: Input mode</p> <p>1: Output mode enabled.</p> 0 p30_do R/W 0 GPIO3 Pin 0 Data OutputIf *p30_oe* is set to 1, this field is used to control the output state of P3.0. <p>0: Output low if *p30_oe* is 1</p> <p>1: Output high if *p30_oe* is 1.</p>"},{"location":"system-power-clocks-reset/#single-inductor-multiple-output-power-supply-simo","title":"Single Inductor Multiple Output Power Supply (SIMO)","text":""}]}